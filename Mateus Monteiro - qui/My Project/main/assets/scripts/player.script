--Define uma proprieadade 'speed' visível no editor, com valor inicial 200
go.property("speed" , 200) 

function init(self)
	self.vida = 3
	self.invencivel = false
	self.tempo_invencivel = 1.0 -- segundos de invencibelidade após dano
	self.timer_invencivel = 0
	self.input = {
		left = false,
		right = false
	}
	self.vel= vmath.vector3(0, 0, 0)
	self.gravidade = -600
	self.forca_pulo = 300
	self.grounded = false

--Pede ao motor para este objetivo receber eventos de input(teclado, rato, etc.)
	msg.post(".","acquire_input_focus")
end

function update(self, dt)
	--cria um vetor de direção inicialização a (0, 0, 0)
	local dir =vmath.vector3()

	-- atualiza a direção com base nas teclas premidas
	if self.input.left then dir.x = dir.x -1 end
	if self.input.right then dir.x = dir.x + 1 end

	-- Se houver movimento (dir~= 0), normalizada e atualiza a posição
	if dir.x ~= 0 then
	--Atualiza velocidade verticalcom gravidade
		dir = vmath.normalize(dir)-- normaliza para manter velocidade constante 
		go.set_position(go.get_position() + dir * self.speed*dt) --move o objeto
	end

	self.vel.y = self.vel.y + self.gravidade * dt

	--cria vetor vertical com gravidade
	local movimento = vmath.vector3(dir.x * self.speed * dt, self.vel.y * dt, 0)

	--Move o objeto
	go.set_position(go.get_position() + movimento)

	--IMPORTANTE: grounded é resetado aqui. Só será relativo em on_message()
	self.grounded = false
	if self.invencivel then
		self.timer_invencivel = self.timer_invencivel - dt
		if self.timer_invencivel <= 0 then
			self.invencivel = false
			self.timer_invencivel = 0
		end
	end
end

function on_input(self, action_id, action)
	--Trata o input para a tecla "left"
	if action_id == hash("left") then

		if action.pressed then
			self.input.left = true -- desativa o movimento à esquerda
		elseif action.released then
			self.input.left = false -- desativa o movimento à esquerda
		end
	end
		-- Trata o input para tecla "right"
	if action_id == hash("right") then

		if action.pressed then
			self.input.right = true -- desativa o movimento à direita
		elseif action.released then
			self.input.right = false -- desativa o movimento à direita
		end
	end
	
	if action_id == hash("jump") then
		if action.pressed and self.grounded then
			self.vel.y = self.forca_pulo
			self.grounded = false
		end
	end
end
function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.group == hash("ground") then
			--verifica se colidiu com o chão (normal apontando para cima)
			if message.normal.y > 0.7 then
				self.grounded = true
				self.vel.y = 0
				-- CORRIGE A POSIÇÃO PARA NÃO AFUNDAR
				local pos = go.get_position()
				pos.y = pos.y + message.distance
				go.set_position(pos)
			end
		elseif message.other_group == hash("enemy") then
			if not self.invencivel then
				msg.post("main:/interface#interface", "atualizar_vida", { valor = self.vida})
				self.invencivel = true
				self.timer_invencivel = self. tempo_invencivelfunction reset_game(self)
			end
		end
	elseif message_id == hash("trigger") then
		--Se o trigger foi ativado e o outro objeto for do grupo "item"
		if message.enter and message.other_group == hash("item") then
			--Apaga o item (por exemplo, uma chave)
			go.delet(message.other_id)
			msg.post("main:/interface#interface", "atualizar_vidaPlayer Script"

function init(self)

				self.vida = 3

				self.invencivel = false

				self.tempo_invencivel = 1.0 -- segundos de invencibilidade após dano

				self.timer_invencivel = 0

				self.input = {

					left = false,

					right = false

				}

				self.vel = vmath.vector3(0, 0, 0)

				self.gravidade = -600

				self.forca_pulo = 450

				self.grounded = false

				msg.post(".", "acquire_input_focus")

			end

			function update(self, dt)

				local dir = vmath.vector3()

				if self.input.left then dir.x = dir.x - 1 end

				if self.input.right then dir.x = dir.x + 1 end

				if dir.x ~= 0 then

					dir = vmath.normalize(dir)

					go.set_position(go.get_position() + dir * self.speed * dt)

				end

				-- Atualiza velocidade vertical com gravidade

				self.vel.y = self.vel.y + self.gravidade * dt

				-- Cria vetor de movimento total

				local movimento = vmath.vector3(dir.x * self.speed * dt, self.vel.y * dt, 0)

				-- Move o objeto

				go.set_position(go.get_position() + movimento)

				-- IMPORTANTE: grounded é resetado aqui. Só será reativado em on_message()

				self.grounded = false

				if self.invencivel then

					self.timer_invencivel = self.timer_invencivel - dt

					if self.timer_invencivel <= 0 then

						self.invencivel = false

						self.timer_invencivel = 0

					end

				end

			end

			function on_input(self, action_id, action)

				if action_id == hash("left") then

					if action.pressed then

						self.input.left = true

					elseif action.released then

						self.input.left = false

					end

				end

				if action_id == hash("right") then

					if action.pressed then

						self.input.right = true

					elseif action.released then

						self.input.right = false

					end

				end

				if action_id == hash("jump") then

					if action.pressed and self.grounded then

						self.vel.y = self.forca_pulo

						self.grounded = false

					end

				end

			end

			function on_message(self, message_id, message, sender)

				if message_id == hash("contact_point_response") then

					if message.group == hash("ground") then

						if message.normal.y > 0.7 then

							self.grounded = true

							self.vel.y = 0

							-- Corrigir a posição para não afundar

							local pos = go.get_position()

							pos.y = pos.y + message.distance

							go.set_position(pos)

						end

					elseif message.other_group == hash("enemy") then

						if not self.invencivel then

							self.vida = self.vida - 1

							msg.post("main:/interface#interface", "atualizar_vida", { valor = self.vida })

							self.invencivel = true

							self.timer_invencivel = self.tempo_invencivel

							if self.vida <= 0 then

								reset_game(self)

							end

						end

					end

				elseif message_id == hash("trigger_response") then

					-- Se o trigger foi ativado e o outro objeto for do grupo "item"

					if message.enter and message.other_group == hash("item") then

						-- Apaga o item (por exemplo, uma chave)

						go.delete(message.other_id)

						-- Atualiza o score

						msg.post("main:/interface#interface", "atualizar_score", {valor = 1})

					end

				end

			end

			function reset_game(self)

				-- Reset de variáveis do player

				self.vida = 3

				self.vel = vmath.vector3(0, 0, 0)

				self.input.left = false

				self.input.right = false

				self.grounded = false

				-- Reset da invencibilidade

				self.invencivel = false

				self.timer_invencivel = 0

				self.tempo_invencivel = 1.0

				-- Reseta a posição do player para a inicial (muda conforme seu setup)

				go.set_position(vmath.vector3(235, 231, 0))

				-- reset do texto das vidas

				msg.post("main:/interface#interface", "atualizar_vida", { valor = self.vida })

			end

			Interface Script
			function init(self)

				gui.set_text(gui.get_node("score"), "Apanha a chave")

				gui.set_text(gui.get_node("life"), "Vidas: 3")

			end

			function on_message(self, message_id, message)

				if message_id == hash("atualizar_score") then

					gui.set_text(gui.get_node("score"), "Chave encontrada!")

				elseif message_id == hash("atualizar_vida") then

					gui.set_text(gui.get_node("life"), "Vidas: " .. message.valor)

				end

			end
